import sys
import os
import subprocess
import numpy as np
import matplotlib.pyplot as plt

# Determine the absolute path to the 'common' directory to facilitate imports
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "../common")))

from KC_structs import ControlSet, Theta, DiscreteState
from KC_searching import Map
from KC_graphics import draw_task_map_fast, draw_task_map

def compile_and_run(
    map_file="maps/Labyrinth.map",
    prim_file="data/base_control_set.txt",
    mesh_file="data/base_mesh_info.txt",
    start=(0, 0, 0),
    goal=(10, 10, 0),
    out_prefix="res/nb_run_",
    weight=1.0
):
    """
    Compiles the C++ planner and executes it in 'single' mode.
    
    This function acts as a Python wrapper around the C++ build system (Make)
    and the compiled binary. It ensures the project is up-to-date and runs
    the planner on the specified problem instance.

    Args:
        map_file (str): Relative path to the grid map file (e.g., .map).
        prim_file (str): Relative path to the motion primitives file.
        mesh_file (str): Relative path to the mesh abstraction file.
        start (tuple): Start configuration (i, j, theta_idx).
        goal (tuple): Goal configuration (i, j, theta_idx).
        out_prefix (str): Prefix for the generated result files.

    Returns:
        dict: A dictionary mapping algorithm names (e.g., 'LBA*') to their 
              corresponding output result file paths. Returns an empty dict on failure.
    """
    root_dir = "../../" 
    
    # 1. Compilation Step
    print("ðŸ”¨ Building C++ project...")
    try:
        # '-s' silences standard output; only errors are shown.
        subprocess.check_call(["make", "mesh_astar", "-s"], cwd=root_dir)
    except subprocess.CalledProcessError:
        print("âŒ Compilation FAILED!")
        return {}

    # 2. Execution Step
    start_str = f"{start[0]} {start[1]} {start[2]}"
    goal_str = f"{goal[0]} {goal[1]} {goal[2]}"
    
    cmd = [
        "./mesh_astar",
        "--mode", "single",
        "--map", map_file,
        "--prim", prim_file,
        "--mesh", mesh_file,
        "--start", start_str,
        "--goal", goal_str,
        "--out-prefix", out_prefix,
        "--weight", str(weight)
    ]

    print(f"ðŸš€ Running planner...")
    try:
        res = subprocess.run(
            cmd, cwd=root_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        if res.returncode != 0:
            print(f"âŒ Execution Error:\n{res.stderr}")
            return {}
    except Exception as e:
        print(f"âŒ Subprocess failed: {e}")
        return {}

    # 3. Output Resolution Step
    # The C++ binary generates files named: {out_prefix}result_{AlgoName}.txt
    # We map clean algorithm names (keys) to their actual file paths.
    algos = ["LBAstar", "MeshAstar", "LazyLBAstar"]
    results = {}
    
    for algo_suffix in algos:
        # Formatting key: "LBAstar" -> "LBA*" for readability
        key_name = algo_suffix.replace("star", "*") 
        filename = f"{out_prefix}result_{algo_suffix}.txt"
        full_path = os.path.join(root_dir, filename)
        
        if os.path.exists(full_path):
            results[key_name] = full_path
            
    return results


def parse_result_file(filepath):
    """
    Parses the structured text output file generated by the C++ planner.

    Args:
        filepath (str): Path to the result file.

    Returns:
        dict: A dictionary containing parsed data including:
              - 'metrics': Search statistics (cost, time, solved status).
              - 'path_ids': Sequence of primitive IDs representing the trajectory.
              - 'map_file': Path to the map file used in the search.
              - 'start', 'finish': Parsed configuration tuples.
    """
    data = {
        "path_ids": [], 
        "map_file": "", 
        "start": None, 
        "finish": None, 
        "metrics": {"solved": "No", "cost": 0.0, "time": 0.0}
    }
    
    if not os.path.exists(filepath):
        return data

    with open(filepath, 'r') as f:
        lines = f.readlines()
        
    for i, line in enumerate(lines):
        line = line.strip()
        
        # Parse Map Filename
        # Handles cases where the line contains extra descriptions like "(with obstacles)"
        if "Map:" in line:
            # Extract text after colon, take the first token as the filename
            raw_val = line.split(":", 1)[1].strip()
            data["map_file"] = raw_val.split()[0]
            
        # Parse Coordinates
        if "Start:" in line:
            content = line.split(":")[1].strip().replace("(", "").replace(")", "")
            data["start"] = [int(x) for x in content.split(",")]
            
        if "Finish:" in line:
            content = line.split(":")[1].strip().replace("(", "").replace(")", "")
            data["finish"] = [int(x) for x in content.split(",")]
            
        # Parse Metrics
        if "Solved:" in line:
            data["metrics"]["solved"] = line.split(":")[1].strip()
        if "Path Cost:" in line:
            data["metrics"]["cost"] = float(line.split(":")[1].strip())
        if "Total Time (s):" in line:
            data["metrics"]["time"] = float(line.split(":")[1].strip())

        # Parse Trajectory
        if "Primitive Sequence (IDs):" in line:
            if i + 1 < len(lines):
                path_line = lines[i+1].strip()
                if path_line:
                    data["path_ids"] = list(map(int, path_line.split()))
                    
    return data


def parse_and_visualize(result_file, prim_file_path, ax=None, root_dir="../../", fast_draw=True):
    """
    Visualizes the planning result by reconstructing the trajectory from motion primitives.

    Args:
        result_file (str): Path to the search result text file.
        prim_file_path (str): Path to the motion primitives definition file.
        ax (matplotlib.axes.Axes, optional): Axes to draw on. Creates new figure if None.
        root_dir (str): Root directory for resolving relative paths.
    """
    data = parse_result_file(result_file)
    
    if not data["start"] or not data["map_file"]:
        print(f"âŒ Failed to parse critical data from {result_file}")
        return

    # 1. Resource Loading
    theta_config = Theta()
    control_set = ControlSet(theta_config)
    
    # Load primitives (geometry of the motions)
    control_set.load_primitives(os.path.join(root_dir, prim_file_path))

    # Load Grid Map
    full_map_path = os.path.join(root_dir, data["map_file"])
    if not os.path.exists(full_map_path):
        print(f"âŒ Map file not found at: {full_map_path}")
        return

    with open(full_map_path, 'r') as f:
        task_map = Map()
        # Assumes MovingAI format or simple grid format handling
        task_map.convert_string_to_cells(f.read(), obs=True)

    start_node = DiscreteState(*data["start"])
    goal_node = DiscreteState(*data["finish"])

    # 2. Rendering the Environment
    # Draws the grid, obstacles, start, and goal positions
    if fast_draw:
        ax = draw_task_map_fast(task_map, start_node, goal_node, theta_config=theta_config, ax_existing=ax)
    else:
        ax = draw_task_map(task_map, start_node, goal_node, theta_config=theta_config, ax_existing=ax)

    # 3. Trajectory Reconstruction & Rendering
    if data["metrics"]["solved"] == "Yes":
        curr_i, curr_j = start_node.i, start_node.j
        
        # Use alternating colors to visually distinguish sequential primitives
        # colors = ['#D32F2F', '#F57C00'] # Dark Red / Orange
        colors = ['r', 'g']
        
        for idx, prim_id in enumerate(data["path_ids"]):
            prim = control_set.list_all_prims[prim_id]
            if not prim: continue
            
            # Coordinate transformation:
            # Primitive coordinates are relative to (0,0). Translate to current (curr_j, curr_i).
            # Note: i maps to Y-axis, j maps to X-axis.
            xs = prim.x_coords + curr_j
            ys = prim.y_coords + curr_i
            
            ax.plot(xs, ys, color=colors[idx % 2], linewidth=1.5, alpha=1.0)
            
            # Update current position for the next primitive
            curr_i += prim.goal.i
            curr_j += prim.goal.j
            
        # ax.set_title(f"Cost: {data['metrics']['cost']} | Time: {data['metrics']['time']}s")
    else:
        ax.set_title("Path Not Found")
