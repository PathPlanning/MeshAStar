#include <cmath>
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
#include <tuple>

#include "KC_structs.hpp"
#include "common.hpp"
#include "rassert.hpp"

// Global memory pool
extern MyHEAP* HEAP;

// -----------------------------------------------------------------------------
// Vertex Implementation
// -----------------------------------------------------------------------------

Vertex::Vertex(int i, int j, int theta) {
    /*
     Constructor for a discrete Lattice State (x, y, theta).
    */
    this->i = i;
    this->j = j;
    this->theta = theta;
}

Vertex::Vertex(int i, int j, int config_id, bool is_mesh_node) {
    /*
     Constructor for an Extended Cell (x, y, Psi).
     
     Asserts that the 'is_mesh_node' flag is true to prevent accidental misuse
     of the Lattice constructor signature.
    */
    rassert(is_mesh_node, "Error: Mesh Vertex constructor called with false flag!");
    
    this->i = i;
    this->j = j;
    this->config_id = config_id;
}

// -----------------------------------------------------------------------------
// Primitive Implementation
// -----------------------------------------------------------------------------

Primitive::Primitive() {
    /*
     Initializes a primitive. 
     Allocates a placeholder vertex for the goal state.
    */
    goal = HEAP->new_Vertex(0, 0, 0);
}

void Primitive::add_collision(int i, int j) {
    /*
     Adds a grid cell to the collision trace (swept volume).
    */
    swept_cells_i.push_back(i);
    swept_cells_j.push_back(j);
}

Primitive::~Primitive() {
    /*
     Releases the goal vertex back to the pool.
    */
    HEAP->delete_Vertex(goal);
}

// -----------------------------------------------------------------------------
// ControlSet Implementation
// -----------------------------------------------------------------------------

ControlSet::ControlSet() {
    prims_by_heading.assign(NUM_HEADINGS, vector<int>());
    list_all_prims.assign(MAX_PRIM_ID, nullptr);
}

static void check_theta(int theta) {
    (void)theta;  
    rassert(0 <= theta && theta < NUM_HEADINGS, "Error: Theta value out of bounds [0, NUM_HEADINGS-1]!");
}

void ControlSet::load_primitives(string _file) {
    /*
     Parses the motion primitive library file.
     The file format is generated by the accompanying Python scripts.
    */

    filename = _file;
    ifstream file(_file);
    rassert(file.is_open(), "Error: Cannot open Control Set file: " + _file);
    
    string line;
    Primitive* prim = nullptr;
    int theta = 0;
    string temp; 

    while (getline(file, line)) {
        stringstream stream(line);

        if (line.find("===== prim description: =====") == 0) {
            prim = new Primitive(); 
            continue;
        }

        // Format: "start heading (number): [theta]"
        if (line.find("start heading (number):") == 0) {
            stream >> temp >> temp >> temp >> theta;
            check_theta(theta);
        }

        // Format: "goal state (i, j, heading num): [i] [j] [theta]"
        if (line.find("goal state (i, j, heading num):") == 0) {
            stream >> temp >> temp >> temp >> temp >> temp >> temp 
                   >> prim->goal->i >> prim->goal->j >> prim->goal->theta;
            check_theta(prim->goal->theta);
        }

        if (line.find("length is:") == 0)
            stream >> temp >> temp >> prim->length;

        // Note: "turning on:" is ignored as it is not used in the C++ search logic.
        if (line.find("turning on:") == 0) {
             stream >> temp >> temp >> temp;
        }

        if (line.find("total heading change:") == 0)
            stream >> temp >> temp >> temp >> prim->accumulated_heading_change;

        if (line.find("prim ID is:") == 0) {
            stream >> temp >> temp >> temp >> prim->id;
            rassert(0 <= prim->id && prim->id < MAX_PRIM_ID, "Primitive ID exceeds MAX_PRIM_ID!");
        }

        // Parse trajectory points (skipped, used for vis only)
        if (line.find("trajectory is:") == 0) {
            while (getline(file, line)) {
                if (line.find("---") == 0) break;
            }
        }

        // Parse collision trace (swept volume)
        // Block ends with "---"
        if (line.find("collision is:") == 0) {
            while (getline(file, line)) {
                if (line.find("---") == 0) break;
                
                stringstream ss_coll(line);
                int i, j;
                ss_coll >> i >> j;
                prim->add_collision(i, j);
            }
        }
                
        if (line.find("prim end") == 0) {
            if (prim != nullptr) {
                prim->start_theta = theta; 
                prims_by_heading[theta].push_back(prim->id);
                list_all_prims[prim->id] = prim;
                
                // Register in boundary value lookup table
                auto key = make_tuple(theta, prim->goal->i, prim->goal->j, prim->goal->theta);
                prim_between_states[key] = prim->id;
            }
        }
    }
    
    file.close();
    cout << "Motion Primitives loaded successfully from " << _file << endl;
}

vector<int>& ControlSet::get_prims_by_heading(int heading) {
    return prims_by_heading[heading];
}

int ControlSet::get_prim_between_states(int st, int di, int dj, int ft) {
    auto key = make_tuple(st, di, dj, ft);
    if (prim_between_states.count(key) == 0)
        return -1;
    return prim_between_states[key];
}

float ControlSet::cost(int id) {
    rassert(0 <= id && id < MAX_PRIM_ID, "Invalid primitive ID!");
    if (list_all_prims[id])
        return (float)list_all_prims[id]->length;
    return 0.0f;
}

ControlSet::~ControlSet() {
    for (Primitive *prim : list_all_prims) {
        if (prim != nullptr) delete prim;
    }
}

// -----------------------------------------------------------------------------
// MeshInfo Implementation
// -----------------------------------------------------------------------------

MeshInfo::MeshInfo() {
    successors.assign(MAX_CONFIGS, vector<tuple<int, int, int, int>>()); 
    initial_config_by_theta.assign(NUM_HEADINGS, -1); 
    
    theta_by_initial_config.assign(MAX_CONFIGS, -1);
    primitives_in_config.assign(MAX_CONFIGS, {});
}

static void check_config_limit(int config_id) {
    (void)config_id;
    rassert(0 <= config_id && config_id < MAX_CONFIGS, "Configuration ID exceeds MAX_CONFIGS! Adjust in common.hpp");
}

void MeshInfo::load(string _file) {
    /*
     Parses the precomputed Mesh Graph topology file.
    */

    filename = _file;
    ifstream file(_file);
    rassert(file.is_open(), "Error: Cannot open Mesh Configuration file: " + _file);

    string line;
    string temp;
    
    while (getline(file, line)) {
        stringstream stream(line);

        // 1. Initial Configuration Forward Mapping
        // Format: "control-set-start with theta: [theta] has type: [config_id]"
        if (line.find("control-set-start with theta:") == 0) {
            int theta, config_id;
            stream >> temp >> temp >> temp >> theta >> temp >> temp >> config_id;
            
            check_theta(theta);
            check_config_limit(config_id);
            
            initial_config_by_theta[theta] = config_id;
            continue;
        }

        // 2. Initial Configuration Reverse Mapping
        // Format: "in goal type: [config_id] ends (or equal starts) prims-in-theta: [theta]"
        if (line.find("in goal type:") == 0) {
            int theta, config_id;
            
            stream >> temp >> temp >> temp >> config_id;
            check_config_limit(config_id);

            // Skip middle words: "ends", "(or", "equal", "starts)", "prims-in-theta:"
            stream >> temp >> temp >> temp >> temp >> temp >> theta;
            check_theta(theta);
            
            theta_by_initial_config[config_id] = theta;
            continue;
        }

        // 3. Successors List
        // Header: "start type is: [config_id]"
        // Data lines: "di dj next_config_id connecting_prim_id"
        if (line.find("start type is:") == 0) {
            int config_id;
            stream >> temp >> temp >> temp >> config_id;
            check_config_limit(config_id);

            while (getline(file, line)) {
                if (line.find("---") == 0) break;
                
                stringstream ss_succ(line);
                int di, dj, next_config, prim_id;
                ss_succ >> di >> dj >> next_config >> prim_id;
                
                successors[config_id].push_back(make_tuple(di, dj, next_config, prim_id));
            }
            continue;
        }

        // 4. Internal Primitives (Endpoints/Finals)
        // Header: "final_thetas_of_type: [config_id] is (ft, di, dj, k, id):"
        // Data lines: "final_theta di dj k_trace prim_id"
        if (line.find("final_thetas_of_type:") == 0) {
            int config_id;
            stream >> temp >> config_id;
            check_config_limit(config_id);

            // The rest of the header line is informational, skip it.
            
            while (getline(file, line)) {
                if (line.find("---") == 0) break;
                
                stringstream ss_prim(line);
                int final_theta, di, dj, k_trace, prim_id;
                ss_prim >> final_theta >> di >> dj >> k_trace >> prim_id;
                
                primitives_in_config[config_id].push_back(make_tuple(final_theta, di, dj, k_trace, prim_id));
            }
            continue;
        }
    }

    cout << "Mesh Configurations loaded successfully from " << _file << endl;
    file.close();
}
